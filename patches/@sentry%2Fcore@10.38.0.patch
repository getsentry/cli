diff --git a/node_modules/@sentry/core/.bun-tag-3268c2da6ddf3847 b/.bun-tag-3268c2da6ddf3847
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/build/cjs/client.js b/build/cjs/client.js
index 492d897927b0a791e0dac10647274e92053ac985..79795fd82d36f419afcb0bb4059ef02b2c525711 100644
--- a/build/cjs/client.js
+++ b/build/cjs/client.js
@@ -108,7 +108,7 @@ function setupWeightBasedFlushing
         flushFn(client);
         // Note: isTimerActive is reset by the flushHook handler above, not here,
         // to avoid race conditions when new items arrive during the flush.
-      }, DEFAULT_FLUSH_INTERVAL);
+      }, DEFAULT_FLUSH_INTERVAL); if (typeof flushTimeout !== 'number' && flushTimeout.unref) flushTimeout.unref();
     }
   });
 
@@ -645,11 +645,16 @@ class Client {
    * `false` otherwise
    */
    async _isClientDoneProcessing(timeout) {
+    // Check immediately first - no need to wait if nothing is processing
+    if (!this._numProcessing) {
+      return true;
+    }
+
     let ticked = 0;
 
     // if no timeout is provided, we wait "forever" until everything is processed
     while (!timeout || ticked < timeout) {
-      await new Promise(resolve => setTimeout(resolve, 1));
+      await new Promise(resolve => { const t = setTimeout(resolve, 1); if (typeof t !== 'number' && t.unref) t.unref(); });
 
       if (!this._numProcessing) {
         return true;
diff --git a/build/cjs/utils/promisebuffer.js b/build/cjs/utils/promisebuffer.js
index 6413b77ec339af98b608c4609fc9462d9a8e967d..85a9af7221cfabcfe5c65df2f4ece5a294d34e61 100644
--- a/build/cjs/utils/promisebuffer.js
+++ b/build/cjs/utils/promisebuffer.js
@@ -71,7 +71,7 @@ function makePromiseBuffer(limit = 100) {
       return drainPromise;
     }
 
-    const promises = [drainPromise, new Promise(resolve => setTimeout(() => resolve(false), timeout))];
+    const promises = [drainPromise, new Promise(resolve => { const t = setTimeout(() => resolve(false), timeout); if (typeof t !== 'number' && t.unref) t.unref(); })];
 
     // Promise.race will resolve to the first promise that resolves or rejects
     // So if the drainPromise resolves, the timeout promise will be ignored
diff --git a/build/esm/client.js b/build/esm/client.js
index bcc614aa8485bd110abc51149370bbf114ac9e54..b98a1e07b0a7c43602105738b8afb38ee1e3db15 100644
--- a/build/esm/client.js
+++ b/build/esm/client.js
@@ -106,7 +106,7 @@ function setupWeightBasedFlushing
         flushFn(client);
         // Note: isTimerActive is reset by the flushHook handler above, not here,
         // to avoid race conditions when new items arrive during the flush.
-      }, DEFAULT_FLUSH_INTERVAL);
+      }, DEFAULT_FLUSH_INTERVAL); if (typeof flushTimeout !== 'number' && flushTimeout.unref) flushTimeout.unref();
     }
   });
 
@@ -643,11 +643,16 @@ class Client {
    * `false` otherwise
    */
    async _isClientDoneProcessing(timeout) {
+    // Check immediately first - no need to wait if nothing is processing
+    if (!this._numProcessing) {
+      return true;
+    }
+
     let ticked = 0;
 
     // if no timeout is provided, we wait "forever" until everything is processed
     while (!timeout || ticked < timeout) {
-      await new Promise(resolve => setTimeout(resolve, 1));
+      await new Promise(resolve => { const t = setTimeout(resolve, 1); if (typeof t !== 'number' && t.unref) t.unref(); });
 
       if (!this._numProcessing) {
         return true;
diff --git a/build/esm/utils/promisebuffer.js b/build/esm/utils/promisebuffer.js
index b8111cf976c8338db28b5e9ff111870864b584cb..458ea7ccb0a2704df1c2c2ec5fb303cff37dc941 100644
--- a/build/esm/utils/promisebuffer.js
+++ b/build/esm/utils/promisebuffer.js
@@ -69,7 +69,7 @@ function makePromiseBuffer(limit = 100) {
       return drainPromise;
     }
 
-    const promises = [drainPromise, new Promise(resolve => setTimeout(() => resolve(false), timeout))];
+    const promises = [drainPromise, new Promise(resolve => { const t = setTimeout(() => resolve(false), timeout); if (typeof t !== 'number' && t.unref) t.unref(); })];
 
     // Promise.race will resolve to the first promise that resolves or rejects
     // So if the drainPromise resolves, the timeout promise will be ignored
