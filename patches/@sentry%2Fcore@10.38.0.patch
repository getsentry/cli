diff --git a/build/cjs/client.js b/build/cjs/client.js
index 492d897927b0a791e0dac10647274e92053ac985..e253ad00bc5f858b62a9581d09688fe7a5d45f23 100644
--- a/build/cjs/client.js
+++ b/build/cjs/client.js
@@ -645,11 +645,16 @@ class Client {
    * `false` otherwise
    */
    async _isClientDoneProcessing(timeout) {
+    // Check immediately first - no need to wait if nothing is processing
+    if (!this._numProcessing) {
+      return true;
+    }
+
     let ticked = 0;
 
     // if no timeout is provided, we wait "forever" until everything is processed
     while (!timeout || ticked < timeout) {
-      await new Promise(resolve => setTimeout(resolve, 1));
+      await new Promise(resolve => { const t = setTimeout(resolve, 1); if (typeof t !== 'number' && t.unref) t.unref(); });
 
       if (!this._numProcessing) {
         return true;
diff --git a/build/cjs/utils/promisebuffer.js b/build/cjs/utils/promisebuffer.js
index 6413b77ec339af98b608c4609fc9462d9a8e967d..85a9af7221cfabcfe5c65df2f4ece5a294d34e61 100644
--- a/build/cjs/utils/promisebuffer.js
+++ b/build/cjs/utils/promisebuffer.js
@@ -71,7 +71,7 @@ function makePromiseBuffer(limit = 100) {
       return drainPromise;
     }
 
-    const promises = [drainPromise, new Promise(resolve => setTimeout(() => resolve(false), timeout))];
+    const promises = [drainPromise, new Promise(resolve => { const t = setTimeout(() => resolve(false), timeout); if (typeof t !== 'number' && t.unref) t.unref(); })];
 
     // Promise.race will resolve to the first promise that resolves or rejects
     // So if the drainPromise resolves, the timeout promise will be ignored
diff --git a/build/esm/client.js b/build/esm/client.js
index bcc614aa8485bd110abc51149370bbf114ac9e54..2677a9bb0b3d9451a0bd50926b3a36516664c69f 100644
--- a/build/esm/client.js
+++ b/build/esm/client.js
@@ -643,11 +643,16 @@ class Client {
    * `false` otherwise
    */
    async _isClientDoneProcessing(timeout) {
+    // Check immediately first - no need to wait if nothing is processing
+    if (!this._numProcessing) {
+      return true;
+    }
+
     let ticked = 0;
 
     // if no timeout is provided, we wait "forever" until everything is processed
     while (!timeout || ticked < timeout) {
-      await new Promise(resolve => setTimeout(resolve, 1));
+      await new Promise(resolve => { const t = setTimeout(resolve, 1); if (typeof t !== 'number' && t.unref) t.unref(); });
 
       if (!this._numProcessing) {
         return true;
diff --git a/build/esm/utils/promisebuffer.js b/build/esm/utils/promisebuffer.js
index b8111cf976c8338db28b5e9ff111870864b584cb..458ea7ccb0a2704df1c2c2ec5fb303cff37dc941 100644
--- a/build/esm/utils/promisebuffer.js
+++ b/build/esm/utils/promisebuffer.js
@@ -69,7 +69,7 @@ function makePromiseBuffer(limit = 100) {
       return drainPromise;
     }
 
-    const promises = [drainPromise, new Promise(resolve => setTimeout(() => resolve(false), timeout))];
+    const promises = [drainPromise, new Promise(resolve => { const t = setTimeout(() => resolve(false), timeout); if (typeof t !== 'number' && t.unref) t.unref(); })];
 
     // Promise.race will resolve to the first promise that resolves or rejects
     // So if the drainPromise resolves, the timeout promise will be ignored
