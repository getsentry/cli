/**
 * Transaction resolver for profile commands.
 *
 * Resolves transaction references (numbers, aliases, or full names) to full transaction names.
 * Works with the cached transaction aliases from `profile list`.
 */

import {
  buildTransactionFingerprint,
  getStaleFingerprint,
  getStaleIndexFingerprint,
  getTransactionByAlias,
  getTransactionByIndex,
} from "./db/transaction-aliases.js";
import { ConfigError } from "./errors.js";

/** Resolved transaction with full name and context */
export type ResolvedTransaction = {
  /** Full transaction name */
  transaction: string;
  /** Organization slug */
  orgSlug: string;
  /** Project slug */
  projectSlug: string;
};

/** Options for transaction resolution */
export type ResolveTransactionOptions = {
  /** Organization slug (required for fingerprint) */
  org: string;
  /** Project slug (null for multi-project lists) */
  project: string | null;
  /** Time period (required for fingerprint validation) */
  period: string;
};

/** Pattern to detect numeric-only input */
const NUMERIC_PATTERN = /^\d+$/;

/**
 * Maximum length for an alias generated by `buildTransactionAliases`.
 * Aliases are shortest-unique-prefixes of normalized transaction segments,
 * so they're always short lowercase strings. This generous upper bound
 * prevents misclassifying bare transaction names (e.g. "process_request")
 * as aliases.
 */
const MAX_ALIAS_LENGTH = 20;

/**
 * Pattern matching alias-shaped input: purely ASCII letters in a single case
 * (all lowercase or all uppercase for caps-lock tolerance).
 *
 * This mirrors how `buildTransactionAliases` generates aliases:
 * segments are lowercased, stripped of hyphens/underscores, then
 * `findShortestUniquePrefixes` produces a lowercase-letter prefix.
 * `disambiguateSegments` prepends "x" characters for duplicates
 * (e.g. "xissues", "xxissues"), so aliases are always purely alphabetic.
 *
 * Mixed-case inputs like "ProcessEvent" are treated as full transaction
 * names since aliases are always lowercase (or all-caps with caps lock).
 */
const ALIAS_PATTERN = /^(?:[a-z]+|[A-Z]+)$/;

/**
 * Check if input looks like a cached alias rather than a full transaction name.
 *
 * Aliases are short, purely alphabetic, single-case strings.
 * Anything containing digits, special characters like `/`, `.`, `-`, `_`,
 * spaces, colons, or mixed-case letters is treated as a full transaction name.
 */
function isAliasLike(input: string): boolean {
  return input.length <= MAX_ALIAS_LENGTH && ALIAS_PATTERN.test(input);
}

/**
 * Parse the stale fingerprint to extract period for error messages.
 * Fingerprint format: "orgSlug:projectSlug:period"
 */
function parseFingerprint(fingerprint: string): {
  org: string;
  project: string | null;
  period: string;
} {
  const parts = fingerprint.split(":");
  return {
    org: parts[0] ?? "",
    project: parts[1] === "*" ? null : (parts[1] ?? null),
    period: parts[2] ?? "",
  };
}

/**
 * Build a helpful error message for stale alias references.
 */
function buildStaleAliasError(
  ref: string,
  staleFingerprint: string,
  currentFingerprint: string
): ConfigError {
  const stale = parseFingerprint(staleFingerprint);
  const current = parseFingerprint(currentFingerprint);

  let reason = "";
  if (stale.period !== current.period) {
    reason = `different time period (cached: ${stale.period}, requested: ${current.period})`;
  } else if (stale.project !== current.project) {
    reason = `different project (cached: ${stale.project ?? "all"}, requested: ${current.project ?? "all"})`;
  } else if (stale.org !== current.org) {
    reason = `different organization (cached: ${stale.org}, requested: ${current.org})`;
  } else {
    reason = "different context";
  }

  const isNumeric = NUMERIC_PATTERN.test(ref);
  const refType = isNumeric ? "index" : "alias";
  const listCmd = buildListCommand(
    current.org,
    current.project,
    current.period
  );

  return new ConfigError(
    `Transaction ${refType} '${ref}' is from a ${reason}.`,
    `Run '${listCmd}' to refresh aliases.`
  );
}

/**
 * Build a suggested `sentry profile list` command string.
 * Uses positional `<org>/<project>` when a project is known, otherwise
 * omits the target to let auto-detection handle it.
 */
function buildListCommand(
  org: string,
  project: string | null,
  period: string
): string {
  const target = project ? ` ${org}/${project}` : "";
  return `sentry profile list${target} --period ${period}`;
}

/**
 * Build error for unknown alias/index.
 */
function buildUnknownRefError(
  ref: string,
  options: ResolveTransactionOptions
): ConfigError {
  const isNumeric = NUMERIC_PATTERN.test(ref);
  const refType = isNumeric ? "index" : "alias";
  const listCmd = buildListCommand(
    options.org,
    options.project,
    options.period
  );

  return new ConfigError(
    `Unknown transaction ${refType} '${ref}'.`,
    `Run '${listCmd}' to see available transactions.`
  );
}

/**
 * Resolve a transaction reference to its full name.
 *
 * Resolution order:
 *   1. Numeric index: "1", "2", "10" → looks up by cached index
 *   2. Alias-shaped input (single-case letters only, ≤20 chars):
 *      "i", "e", "iu", "xissues", "I" (caps lock) → looks up by cached alias
 *   3. Everything else is treated as a full transaction name and passed through:
 *      "/api/0/...", "tasks.process", "process_request", "handle-webhook",
 *      "ProcessEvent", "GET /users"
 *
 * @throws ConfigError if alias/index not found or stale
 */
export function resolveTransaction(
  input: string,
  options: ResolveTransactionOptions
): ResolvedTransaction {
  // Numeric input → look up by index (checked first since "123" is unambiguous)
  const currentFingerprint = buildTransactionFingerprint(
    options.org,
    options.project,
    options.period
  );

  if (NUMERIC_PATTERN.test(input)) {
    const idx = Number.parseInt(input, 10);
    const entry = getTransactionByIndex(idx, currentFingerprint);

    if (entry) {
      return {
        transaction: entry.transaction,
        orgSlug: entry.orgSlug,
        projectSlug: entry.projectSlug,
      };
    }

    // Check if there's a stale entry for this index in a different context
    const staleFingerprint = getStaleIndexFingerprint(idx, currentFingerprint);
    if (staleFingerprint) {
      throw buildStaleAliasError(input, staleFingerprint, currentFingerprint);
    }

    throw buildUnknownRefError(input, options);
  }

  // Alias-shaped input → look up by alias
  if (isAliasLike(input)) {
    const entry = getTransactionByAlias(input, currentFingerprint);

    if (entry) {
      return {
        transaction: entry.transaction,
        orgSlug: entry.orgSlug,
        projectSlug: entry.projectSlug,
      };
    }

    // Check if there's a stale entry for this alias in a different context
    const staleFingerprint = getStaleFingerprint(input, currentFingerprint);
    if (staleFingerprint) {
      throw buildStaleAliasError(input, staleFingerprint, currentFingerprint);
    }

    throw buildUnknownRefError(input, options);
  }

  // Everything else is a full transaction name — pass through directly.
  // This handles URL paths ("/api/users"), dotted names ("tasks.process"),
  // and bare names with special chars ("process_request", "handle-webhook").
  return {
    transaction: input,
    orgSlug: options.org,
    projectSlug: options.project ?? "",
  };
}
